# 数据库读写分离配置指南

## 概述

本项目已实现数据库读写分离功能，将读操作路由到从库，写操作路由到主库，以提升系统并发处理能力。

## 架构说明

### 数据源路由机制

```
┌─────────────────────────────────────────────┐
│           Spring Application                │
├─────────────────────────────────────────────┤
│                                             │
│  ┌──────────────────────────────────────┐  │
│  │      DataSourceAspect (AOP)          │  │
│  │  - 拦截 Service/Repository 方法       │  │
│  │  - 根据注解/方法名判断数据源          │  │
│  └──────────────┬───────────────────────┘  │
│                 │                           │
│  ┌──────────────▼───────────────────────┐  │
│  │   DataSourceContextHolder            │  │
│  │  - ThreadLocal 存储数据源类型         │  │
│  └──────────────┬───────────────────────┘  │
│                 │                           │
│  ┌──────────────▼───────────────────────┐  │
│  │    DynamicDataSource (路由器)        │  │
│  │  - 根据上下文动态选择数据源           │  │
│  └──────┬──────────────────────┬────────┘  │
│         │                      │            │
│  ┌──────▼──────┐        ┌─────▼────────┐   │
│  │ Master DS   │        │  Slave DS    │   │
│  │ (主库)      │        │  (从库)      │   │
│  └──────┬──────┘        └──────┬───────┘   │
└─────────┼──────────────────────┼───────────┘
          │                      │
   ┌──────▼──────┐        ┌─────▼────────┐
   │MySQL Master │───────>│ MySQL Slave  │
   │ (localhost  │  复制  │ (localhost   │
   │  :3306)     │        │  :3307)      │
   └─────────────┘        └──────────────┘
```

### 数据源路由规则

**优先级从高到低：**

1. **写事务** - `@Transactional(readOnly=false)` → 主库
2. **只读事务** - `@Transactional(readOnly=true)` → 从库
3. **只读注解** - `@ReadOnly` → 从库
4. **方法名启发式判断** - `find*`, `get*`, `query*`, `select*`, `count*`, `exists*` → 从库
5. **默认** - 主库

### 连接池配置

- **主库（Master）**: 200 连接 - 写操作较少但重要
- **从库（Slave）**: 300 连接 - 读操作更多

## 文件说明

### 核心组件

1. **DataSourceType.java** - 数据源类型枚举
   - `MASTER`: 主库
   - `SLAVE`: 从库

2. **DataSourceContextHolder.java** - 数据源上下文持有者
   - 使用 `ThreadLocal` 存储当前线程的数据源类型
   - 线程安全，不同线程互不影响

3. **DynamicDataSource.java** - 动态数据源路由器
   - 继承 `AbstractRoutingDataSource`
   - 在每次数据库操作前自动选择数据源

4. **DataSourceConfig.java** - 多数据源配置类
   - 配置主库和从库数据源
   - 创建动态数据源 Bean

5. **@ReadOnly** - 只读操作注解
   - 标记在方法或类上
   - 标记的方法将被路由到从库

6. **DataSourceAspect.java** - 数据源切面
   - AOP 拦截 Service/Repository 方法
   - 自动根据注解和方法名路由数据源

### 配置文件

**application.yml**

```yaml
spring:
  datasource:
    # 主库配置
    master:
      jdbc-url: jdbc:mysql://localhost:3306/taskdb?useSSL=false&serverTimezone=UTC
      username: taskuser
      password: taskpass
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 200
        minimum-idle: 30
        pool-name: MasterHikariPool

    # 从库配置
    slave:
      jdbc-url: jdbc:mysql://localhost:3307/taskdb?useSSL=false&serverTimezone=UTC
      username: taskuser
      password: taskpass
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 300
        minimum-idle: 50
        pool-name: SlaveHikariPool
```

## MySQL 主从复制配置

### 前置条件

- MySQL 8.0+
- 两个 MySQL 实例（主库 3306，从库 3307）

### 主库配置（localhost:3306）

1. **编辑 my.cnf**

```ini
[mysqld]
# 服务器 ID（集群内唯一）
server-id=1

# 开启二进制日志
log-bin=mysql-bin
binlog_format=ROW

# 要复制的数据库
binlog-do-db=taskdb

# 不要复制的数据库
binlog-ignore-db=mysql
binlog-ignore-db=information_schema
binlog-ignore-db=performance_schema
```

2. **重启主库**

```bash
sudo systemctl restart mysql
# 或
sudo service mysql restart
```

3. **创建复制用户**

```sql
-- 连接到主库
mysql -u root -p

-- 创建复制用户
CREATE USER 'repl'@'%' IDENTIFIED BY 'repl_password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;

-- 查看主库状态（记录 File 和 Position）
SHOW MASTER STATUS;
```

输出示例：
```
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000001 |      154 | taskdb       | mysql,...        |
+------------------+----------+--------------+------------------+
```

### 从库配置（localhost:3307）

1. **编辑 my.cnf**

```ini
[mysqld]
# 服务器 ID（与主库不同）
server-id=2

# 从库端口
port=3307

# 中继日志
relay-log=mysql-relay-bin

# 只读模式（可选，防止从库写入）
read_only=1
```

2. **重启从库**

```bash
sudo systemctl restart mysql
# 或
sudo service mysql restart
```

3. **配置主从复制**

```sql
-- 连接到从库
mysql -u root -p -P 3307

-- 停止从库复制（如果已经在运行）
STOP SLAVE;

-- 配置主库信息（使用上面记录的 File 和 Position）
CHANGE MASTER TO
  MASTER_HOST='localhost',
  MASTER_PORT=3306,
  MASTER_USER='repl',
  MASTER_PASSWORD='repl_password',
  MASTER_LOG_FILE='mysql-bin.000001',
  MASTER_LOG_POS=154;

-- 启动从库复制
START SLAVE;

-- 检查从库状态
SHOW SLAVE STATUS\G
```

4. **验证复制状态**

检查以下两项是否为 `Yes`：
- `Slave_IO_Running: Yes`
- `Slave_SQL_Running: Yes`

如果都是 `Yes`，说明主从复制配置成功。

### 使用 Docker Compose 快速搭建（推荐）

创建 `docker-compose-mysql-replication.yml`：

```yaml
version: '3.8'

services:
  mysql-master:
    image: mysql:8.0
    container_name: mysql-master
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
      MYSQL_DATABASE: taskdb
      MYSQL_USER: taskuser
      MYSQL_PASSWORD: taskpass
    command:
      - --server-id=1
      - --log-bin=mysql-bin
      - --binlog-format=ROW
      - --binlog-do-db=taskdb
    volumes:
      - mysql-master-data:/var/lib/mysql

  mysql-slave:
    image: mysql:8.0
    container_name: mysql-slave
    ports:
      - "3307:3306"
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
      MYSQL_DATABASE: taskdb
      MYSQL_USER: taskuser
      MYSQL_PASSWORD: taskpass
    command:
      - --server-id=2
      - --relay-log=mysql-relay-bin
      - --read-only=1
    volumes:
      - mysql-slave-data:/var/lib/mysql
    depends_on:
      - mysql-master

volumes:
  mysql-master-data:
  mysql-slave-data:
```

启动：

```bash
docker-compose -f docker-compose-mysql-replication.yml up -d
```

配置复制（在从库中执行）：

```bash
# 连接到从库
docker exec -it mysql-slave mysql -u root -p

# 执行上面的 CHANGE MASTER TO 命令
CHANGE MASTER TO
  MASTER_HOST='mysql-master',
  MASTER_PORT=3306,
  MASTER_USER='repl',
  MASTER_PASSWORD='repl_password',
  MASTER_LOG_FILE='mysql-bin.000001',
  MASTER_LOG_POS=154;

START SLAVE;
SHOW SLAVE STATUS\G
```

## 使用指南

### 在 Repository 层使用

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    // 自动路由到从库（方法名以 find 开头）
    @ReadOnly
    Optional<User> findByUsername(String username);

    // 自动路由到从库（方法名以 exists 开头）
    @ReadOnly
    boolean existsByUsername(String username);

    // 必须在主库执行（悲观锁）
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT u FROM User u WHERE u.id = :id")
    Optional<User> findByIdWithLock(@Param("id") Long id);
}
```

### 在 Service 层使用

```java
@Service
public class UserService {

    // 写操作 - 自动路由到主库
    @Transactional
    public User createUser(User user) {
        return userRepository.save(user);
    }

    // 只读操作 - 自动路由到从库
    @Transactional(readOnly = true)
    public User getUser(Long id) {
        return userRepository.findById(id).orElse(null);
    }

    // 或使用 @ReadOnly 注解
    @ReadOnly
    public User getUserByUsername(String username) {
        return userRepository.findByUsername(username).orElse(null);
    }
}
```

## 测试验证

运行读写分离测试：

```bash
./mvnw test -Dtest=ReadWriteSplittingTest
```

测试涵盖：
1. DataSourceContextHolder 功能
2. 读操作使用从库
3. 写操作使用主库
4. 事务中的操作使用正确的数据源
5. 悲观锁查询使用主库
6. exists 操作使用从库
7. 混合读写操作
8. 数据源线程隔离

## 监控和调试

### 启用 SQL 日志

在 `application.yml` 中：

```yaml
spring:
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true

logging:
  level:
    com.slotgame.aspect.DataSourceAspect: DEBUG
    com.slotgame.config.datasource: DEBUG
```

### 查看日志输出

日志会显示每个方法使用的数据源：

```
DEBUG c.s.aspect.DataSourceAspect - Method: UserRepository.findByUsername -> Using SLAVE datasource
DEBUG c.s.aspect.DataSourceAspect - Method: UserRepository.save -> Using MASTER datasource
```

## 注意事项

### 主从延迟问题

主从复制存在一定延迟（通常 < 1ms），可能导致：

1. **写后立即读** - 可能读不到刚写入的数据

   **解决方案**：
   - 写操作后如果需要立即读取，使用主库读取
   - 在事务内的读写操作会自动使用主库

   ```java
   @Transactional  // 事务内所有操作都使用主库
   public void updateAndRead() {
       userRepository.save(user);  // 写 - 主库
       User updated = userRepository.findById(user.getId()).get();  // 读 - 主库
   }
   ```

2. **强一致性要求** - 关键业务操作需要强一致性

   **解决方案**：
   - 不使用 `@ReadOnly` 注解
   - 或明确指定使用主库

   ```java
   // 手动指定使用主库
   DataSourceContextHolder.setDataSourceType(DataSourceType.MASTER);
   try {
       User user = userRepository.findById(id).get();
   } finally {
       DataSourceContextHolder.clearDataSourceType();
   }
   ```

### 事务管理

- `@Transactional` 注解的方法内，所有操作都会使用同一个数据源
- 写事务（`readOnly=false`）使用主库
- 只读事务（`readOnly=true`）使用从库

### 悲观锁和乐观锁

- **悲观锁** (`SELECT FOR UPDATE`) 必须在主库执行
- **乐观锁** (`@Version`) 读从库，写主库

## 性能提升

读写分离带来的性能提升：

1. **读写负载分离** - 主库专注写操作，从库处理大量读操作
2. **连接池优化** - 主库 200 连接，从库 300 连接
3. **并发能力提升** - 从 150-250 QPS 提升到 300-500 QPS（预估）
4. **横向扩展** - 可以添加多个从库进一步提升读能力

## 故障处理

### 从库宕机

- 系统会尝试连接从库失败
- 需要配置故障转移机制或手动切换到主库

### 主库宕机

- 所有写操作失败
- 需要提升从库为主库（主从切换）

### 复制延迟过大

```sql
-- 在从库检查延迟
SHOW SLAVE STATUS\G

-- 查看 Seconds_Behind_Master 字段
-- 如果延迟过大，考虑：
-- 1. 优化网络
-- 2. 升级从库硬件
-- 3. 减少主库写入压力
```

## 下一步优化

1. **多从库支持** - 配置多个从库，负载均衡
2. **从库故障转移** - 自动检测从库故障，切换到其他从库或主库
3. **读写分离中间件** - 使用 MyCAT、ProxySQL 等中间件
4. **缓存层** - 在从库前增加 Redis 缓存层，进一步减轻数据库压力

## 参考资料

- [MySQL 主从复制官方文档](https://dev.mysql.com/doc/refman/8.0/en/replication.html)
- [Spring AbstractRoutingDataSource](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/lookup/AbstractRoutingDataSource.html)
- [ThreadLocal 最佳实践](https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html)
